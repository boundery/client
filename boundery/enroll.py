from bottle import get, post, template, request, response, redirect, abort
import requests
import os, sys, time, json, atexit, socket, base64
from libnacl.secret import SecretBox
import libnacl
import libnacl.utils
from hkdf import hkdf_extract, hkdf_expand
import osal
from settings import CENTRAL_URL

#XXX Make sure this is restartable at any point, in case the client
#    crashes/is shutdown/reloads HTML/etc.

#XXX Add /step1 to write ZIP, cryptobox.sk and wifi password.
#    /mnt/config/pairingkey, /mnt/config/wifi.txt

#These globals require either a threaded WSGI server, serial, or asyncio one.
privsub = None
def do_priv(cmd):
    global privsub
    if not privsub:
        import __main__
        privsub = osal.sudo(sys.executable, os.path.abspath(__main__.__file__), "--privsub")
        line = privsub.stdout.readline().strip() #XXX timeout?
        if line != "ok":
            raise Exception("privsub startup failed: " + line)

    privsub.stdin.write(cmd + '\n')
    privsub.stdin.flush()

    line = privsub.stdout.readline().strip()
    if line.startswith("ERROR "):
        raise Exception(line)
    return line

def finish_priv():
    global privsub
    if privsub:
        try:
            do_priv('exit')
            privsub.wait(timeout=5)
            privsub = None
        except:
            pass
atexit.register(finish_priv)

datacache = {}
def get_from_datadir(name):
    if not name in datacache:
        try:
            datadir = osal.get_data_dir("boundery")
            with open(os.path.join(datadir, name), 'r') as f:
                datacache[name] = f.read().strip()
        except:
            datacache.pop(name, None)
    return datacache[name]

pairing_key = b'X'*32 #XXX Needs to be generated by libnacl.randombytes(32), or recieved from the pi.
def get_subkey(keyname, salt = None):
    if type(keyname) == str:
        keyname = keyname.encode()
    global pairing_key
    if not pairing_key:
        pairing_key = libnacl.randombytes(32)
    return hkdf_expand(hkdf_extract(salt, pairing_key), keyname, 32)

bootstrap_ipv6 = None
network_id = None

#########################

@get('/')
@get('/step2')
def step2():
    if ':' in request.urlparts.netloc:
        port = request.urlparts.netloc.split(':')[1]
    else:
        port = 80
    return template("step2", port=port, central_url=CENTRAL_URL)

@get('/step3')
def step3():
    #XXX What to do if there is no apikey in request?
    apikey = request.query.apikey
    username = request.query.username
    datadir = osal.get_data_dir("boundery")
    #XXX Handle errors writing.
    with open(os.path.join(datadir, "apikey"), 'w') as f:
        f.write(apikey)
    with open(os.path.join(datadir, "username"), 'w') as f:
        f.write(username)

    return redirect("/step4")

@get('/step4')
def step4():
    #XXX This pops up an auth dialog without warning.  Should explain what is
    #    about to happen, then have the user click "go".
    do_priv("join ff05390539000000")
    return template("step4", central_url=CENTRAL_URL)

@post('/step4_api1')
def step4_api1():
    pairing_id = base64.standard_b64encode(get_subkey("pairing_id"))
    r = requests.post(CENTRAL_URL + "/api/v1/get_server_bootstrap/",
                        data = { "APIKEY": get_from_datadir("apikey"),
                                   "PAIRING_ID": pairing_id, })
    if r.status_code == 200:
        global bootstrap_ipv6
        bootstrap_ipv6 = r.json()["bootstrap_ipv6"]
        return "ok"
    else:
        abort(404, "Not found")

@post('/step4_api2')
def step4_api2():
    hkdf_salt = libnacl.randombytes(32)
    nodeid = do_priv("get_nodeid")
    to_server_key = get_subkey("to_server", hkdf_salt)
    ciphertext = SecretBox(to_server_key).encrypt(nodeid.encode())

    with socket.socket(socket.AF_INET6, socket.SOCK_STREAM) as s:
        s.settimeout(5)
        s.connect((bootstrap_ipv6, 1337))

        assert(len(hkdf_salt) < 256)
        s.sendall(len(hkdf_salt).to_bytes(1, byteorder='big') + hkdf_salt)
        assert(len(ciphertext) < 256)
        s.sendall(len(ciphertext).to_bytes(1, byteorder='big') + ciphertext)

        num_bytes = int.from_bytes(s.recv(1), byteorder='big')
        resp=b''
        while len(resp) < num_bytes:
            resp += s.recv(num_bytes - len(resp))

    from_server_key = get_subkey("from_server", hkdf_salt)
    global network_id
    network_id = SecretBox(from_server_key).decrypt(resp).decode()

    do_priv("join %s" % network_id)

    return "ok"

@post('/step4_api3')
def step4_api3():
    status = do_priv("joinstatus %s" % network_id)
    if status == "OK":
        do_priv("leave ff05390539000000")
        return "ok"
    else:
        abort(404, "Not found")

#########################

def zt_do(authtoken, method, path, data = None):
    headers = { 'Connection': 'close',
                'Content-Type': 'application/json',
                'X-ZT1-Auth': authtoken }

    url = "http://localhost:9993/%s" % path

    if data is not None:
        r = method(url, headers = headers, data = json.dumps(data))
    else:
        r = method(url, headers = headers)

    if r.status_code == 200 and len(r.text) != 0:
        return r.json()
    else:
        return None

def zt_get(authtoken, path):
    return zt_do(authtoken, requests.get, path)
def zt_post(authtoken, path, data):
    return zt_do(authtoken, requests.post, path, data)
def zt_delete(authtoken, path):
    return zt_do(authtoken, requests.delete, path)

def privsub_run():
    try:
        with open(osal.get_zerotier_token_path(), 'r') as f:
            authtoken = f.read().strip()
    except:
        authtoken = None
    if authtoken is None or authtoken == '':
        print("ERROR can't read authtoken")
        sys.exit(10)
    print("ok")
    sys.stdout.flush()

    for line in sys.stdin:
        try:
            line = line.strip()
            if line == "get_nodeid":
                json = zt_get(authtoken, "status")
                print(json.get("address"))
            elif line.startswith("join "):
                netid = line.split(' ')[1]
                zt_post(authtoken, "network/%s" % netid, {})
                print("ok") #XXX Error handling
            elif line.startswith("joinstatus "):
                netid = line.split(' ')[1]
                status = zt_get(authtoken, "network/%s" % netid).get("status", "")
                print(status)
            elif line.startswith("leave "):
                netid = line.split(' ')[1]
                zt_delete(authtoken, "network/%s" % netid)
                print("ok") #XXX Error handling
            elif line == "exit":
                sys.exit()
        except Exception as e:
            print("ERROR exception %s" % repr(e))

        sys.stdout.flush()
        sys.stderr.flush()
